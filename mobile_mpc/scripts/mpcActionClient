#! /usr/bin/env python

import rospy

# Brings in the SimpleActionClient
import actionlib
import numpy as np

from std_msgs.msg import Float64MultiArray

# Brings in the messages used by the fibonacci action, including the
# goal message and the result message.
import mobile_mpc.msg


def mpc_client():
    # Creates the SimpleActionClient, passing the type of the action
    # (FibonacciAction) to the constructor.
    client = actionlib.SimpleActionClient(
        "mpc", mobile_mpc.msg.mpcAction
    )

    # Waits until the action server has started up and started
    # listening for goals.
    client.wait_for_server()

    # Creates a goal to send to the action server.
    goals = []
    goalData1 = Float64MultiArray()
    goalData1.data = np.array([-2,-2, 0, 1 , 0 ,0 ,-1, 0, 1, 0])
    goals.append(goalData1)
    goalData2 = Float64MultiArray()
    goalData2.data = np.array([3, 3, -1, 1 , 0 ,0 ,-1, 0, 1, 0])
    goals.append(goalData2)
    goalData3 = Float64MultiArray()
    goalData3.data = np.array([1, 7, -1, 1 , -1 ,0 ,-1, 0, 1, 0])
    goals.append(goalData3)

    for oneGoal in goals:
        goal = mobile_mpc.msg.mpcGoal(goal= oneGoal)

        # Sends the goal to the action server.
        client.send_goal(goal)

        # Waits for the server to finish performing the action.
        client.wait_for_result()

        # Prints out the result of executing the action
        print(client.get_result())
    return client.get_result()  # A FibonacciResult


if __name__ == "__main__":
    try:
        # Initializes a rospy node so that the SimpleActionClient can
        # publish and subscribe over ROS.
        rospy.init_node("mpc_client_node")
        result = mpc_client()
        print("Result:", result)
    except rospy.ROSInterruptException:
        print("program interrupted before completion")
